Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> class_decl_list
Rule 2     class_decl_list -> class_decl class_decl_list
Rule 3     class_decl_list -> <empty>
Rule 4     class_decl -> CLASS ID extends LBRACE class_body_decl_list RBRACE
Rule 5     class_decl -> CLASS ID extends LBRACE error RBRACE
Rule 6     extends -> EXTENDS ID
Rule 7     extends -> <empty>
Rule 8     class_body_decl_list -> class_body_decl_list class_body_decl
Rule 9     class_body_decl_list -> class_body_decl
Rule 10    class_body_decl -> field_decl
Rule 11    class_body_decl -> method_decl
Rule 12    class_body_decl -> constructor_decl
Rule 13    field_decl -> mod var_decl
Rule 14    method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block
Rule 15    method_decl -> mod type ID LPAREN param_list_opt RPAREN block
Rule 16    constructor_decl -> mod ID LPAREN param_list_opt RPAREN block
Rule 17    mod -> visibility_mod storage_mod
Rule 18    visibility_mod -> PUBLIC
Rule 19    visibility_mod -> PRIVATE
Rule 20    visibility_mod -> <empty>
Rule 21    storage_mod -> STATIC
Rule 22    storage_mod -> <empty>
Rule 23    var_decl -> type var_list SEMICOLON
Rule 24    type -> INT
Rule 25    type -> BOOLEAN
Rule 26    type -> FLOAT
Rule 27    type -> ID
Rule 28    var_list -> var_list COMMA var
Rule 29    var_list -> var
Rule 30    var -> ID
Rule 31    var -> var LBRACKET RBRACKET
Rule 32    param_list_opt -> param_list
Rule 33    param_list_opt -> <empty>
Rule 34    param_list -> param_list COMMA param
Rule 35    param_list -> param
Rule 36    param -> type ID
Rule 37    block -> LBRACE stmt_list RBRACE
Rule 38    block -> LBRACE stmt_list error RBRACE
Rule 39    stmt_list -> <empty>
Rule 40    stmt_list -> stmt_list stmt
Rule 41    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 42    stmt -> IF LPAREN expr RPAREN stmt
Rule 43    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 44    stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
Rule 45    stmt -> RETURN expr_opt SEMICOLON
Rule 46    stmt -> stmt_expr SEMICOLON
Rule 47    stmt -> BREAK SEMICOLON
Rule 48    stmt -> CONTINUE SEMICOLON
Rule 49    stmt -> block
Rule 50    stmt -> var_decl
Rule 51    stmt -> error SEMICOLON
Rule 52    literal -> INT_CONST
Rule 53    literal -> FLOAT_CONST
Rule 54    literal -> STRING_CONST
Rule 55    literal -> NULL
Rule 56    literal -> TRUE
Rule 57    literal -> FALSE
Rule 58    primary -> literal
Rule 59    primary -> THIS
Rule 60    primary -> SUPER
Rule 61    primary -> LPAREN expr RPAREN
Rule 62    primary -> NEW ID LPAREN args_opt RPAREN
Rule 63    primary -> lhs
Rule 64    primary -> method_invocation
Rule 65    args_opt -> arg_plus
Rule 66    args_opt -> <empty>
Rule 67    arg_plus -> arg_plus COMMA expr
Rule 68    arg_plus -> expr
Rule 69    lhs -> field_access
Rule 70    lhs -> array_access
Rule 71    field_access -> primary DOT ID
Rule 72    field_access -> ID
Rule 73    array_access -> primary LBRACKET expr RBRACKET
Rule 74    method_invocation -> field_access LPAREN args_opt RPAREN
Rule 75    expr -> primary
Rule 76    expr -> assign
Rule 77    expr -> new_array
Rule 78    expr -> expr PLUS expr
Rule 79    expr -> expr MINUS expr
Rule 80    expr -> expr MULTIPLY expr
Rule 81    expr -> expr DIVIDE expr
Rule 82    expr -> expr EQ expr
Rule 83    expr -> expr NEQ expr
Rule 84    expr -> expr LT expr
Rule 85    expr -> expr LEQ expr
Rule 86    expr -> expr GT expr
Rule 87    expr -> expr GEQ expr
Rule 88    expr -> expr AND expr
Rule 89    expr -> expr OR expr
Rule 90    expr -> PLUS expr
Rule 91    expr -> MINUS expr
Rule 92    expr -> NOT expr
Rule 93    assign -> lhs ASSIGN expr
Rule 94    assign -> lhs INC
Rule 95    assign -> INC lhs
Rule 96    assign -> lhs DEC
Rule 97    assign -> DEC lhs
Rule 98    new_array -> NEW type dim_expr_plus dim_star
Rule 99    dim_expr_plus -> dim_expr_plus dim_expr
Rule 100   dim_expr_plus -> dim_expr
Rule 101   dim_expr -> LBRACKET expr RBRACKET
Rule 102   dim_star -> LBRACKET RBRACKET dim_star
Rule 103   dim_star -> <empty>
Rule 104   stmt_expr -> assign
Rule 105   stmt_expr -> method_invocation
Rule 106   stmt_expr_opt -> stmt_expr
Rule 107   stmt_expr_opt -> <empty>
Rule 108   expr_opt -> expr
Rule 109   expr_opt -> <empty>

Terminals, with rules where they appear

AND                  : 88
ASSIGN               : 93
BOOLEAN              : 25
BREAK                : 47
CLASS                : 4 5
COMMA                : 28 34 67
CONTINUE             : 48
DEC                  : 96 97
DIVIDE               : 81
DOT                  : 71
ELSE                 : 41
EQ                   : 82
EXTENDS              : 6
FALSE                : 57
FLOAT                : 26
FLOAT_CONST          : 53
FOR                  : 44
GEQ                  : 87
GT                   : 86
ID                   : 4 5 6 14 15 16 27 30 36 62 71 72
IF                   : 41 42
INC                  : 94 95
INT                  : 24
INT_CONST            : 52
LBRACE               : 4 5 37 38
LBRACKET             : 31 73 101 102
LEQ                  : 85
LPAREN               : 14 15 16 41 42 43 44 61 62 74
LT                   : 84
MINUS                : 79 91
MULTIPLY             : 80
NEQ                  : 83
NEW                  : 62 98
NOT                  : 92
NULL                 : 55
OR                   : 89
PLUS                 : 78 90
PRIVATE              : 19
PUBLIC               : 18
RBRACE               : 4 5 37 38
RBRACKET             : 31 73 101 102
RETURN               : 45
RPAREN               : 14 15 16 41 42 43 44 61 62 74
SEMICOLON            : 23 44 44 45 46 47 48 51
STATIC               : 21
STRING_CONST         : 54
SUPER                : 60
THIS                 : 59
TRUE                 : 56
VOID                 : 14
WHILE                : 43
error                : 5 38 51

Nonterminals, with rules where they appear

arg_plus             : 65 67
args_opt             : 62 74
array_access         : 70
assign               : 76 104
block                : 14 15 16 49
class_body_decl      : 8 9
class_body_decl_list : 4 8
class_decl           : 2
class_decl_list      : 1 2
constructor_decl     : 12
dim_expr             : 99 100
dim_expr_plus        : 98 99
dim_star             : 98 102
expr                 : 41 42 43 61 67 68 73 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 91 92 93 101 108
expr_opt             : 44 45
extends              : 4 5
field_access         : 69 74
field_decl           : 10
lhs                  : 63 93 94 95 96 97
literal              : 58
method_decl          : 11
method_invocation    : 64 105
mod                  : 13 14 15 16
new_array            : 77
param                : 34 35
param_list           : 32 34
param_list_opt       : 14 15 16
pgm                  : 0
primary              : 71 73 75
stmt                 : 40 41 41 42 43 44
stmt_expr            : 46 106
stmt_expr_opt        : 44 44
stmt_list            : 37 38 40
storage_mod          : 17
type                 : 15 23 36 98
var                  : 28 29 31
var_decl             : 13 50
var_list             : 23 28
visibility_mod       : 17

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . class_decl_list
    (2) class_decl_list -> . class_decl class_decl_list
    (3) class_decl_list -> .
    (4) class_decl -> . CLASS ID extends LBRACE class_body_decl_list RBRACE
    (5) class_decl -> . CLASS ID extends LBRACE error RBRACE

    $end            reduce using rule 3 (class_decl_list -> .)
    CLASS           shift and go to state 2

    class_decl_list                shift and go to state 4
    pgm                            shift and go to state 1
    class_decl                     shift and go to state 3

state 1

    (0) S' -> pgm .



state 2

    (4) class_decl -> CLASS . ID extends LBRACE class_body_decl_list RBRACE
    (5) class_decl -> CLASS . ID extends LBRACE error RBRACE

    ID              shift and go to state 5


state 3

    (2) class_decl_list -> class_decl . class_decl_list
    (2) class_decl_list -> . class_decl class_decl_list
    (3) class_decl_list -> .
    (4) class_decl -> . CLASS ID extends LBRACE class_body_decl_list RBRACE
    (5) class_decl -> . CLASS ID extends LBRACE error RBRACE

    $end            reduce using rule 3 (class_decl_list -> .)
    CLASS           shift and go to state 2

    class_decl_list                shift and go to state 6
    class_decl                     shift and go to state 3

state 4

    (1) pgm -> class_decl_list .

    $end            reduce using rule 1 (pgm -> class_decl_list .)


state 5

    (4) class_decl -> CLASS ID . extends LBRACE class_body_decl_list RBRACE
    (5) class_decl -> CLASS ID . extends LBRACE error RBRACE
    (6) extends -> . EXTENDS ID
    (7) extends -> .

    EXTENDS         shift and go to state 8
    LBRACE          reduce using rule 7 (extends -> .)

    extends                        shift and go to state 7

state 6

    (2) class_decl_list -> class_decl class_decl_list .

    $end            reduce using rule 2 (class_decl_list -> class_decl class_decl_list .)


state 7

    (4) class_decl -> CLASS ID extends . LBRACE class_body_decl_list RBRACE
    (5) class_decl -> CLASS ID extends . LBRACE error RBRACE

    LBRACE          shift and go to state 9


state 8

    (6) extends -> EXTENDS . ID

    ID              shift and go to state 10


state 9

    (4) class_decl -> CLASS ID extends LBRACE . class_body_decl_list RBRACE
    (5) class_decl -> CLASS ID extends LBRACE . error RBRACE
    (8) class_body_decl_list -> . class_body_decl_list class_body_decl
    (9) class_body_decl_list -> . class_body_decl
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . mod var_decl
    (14) method_decl -> . mod VOID ID LPAREN param_list_opt RPAREN block
    (15) method_decl -> . mod type ID LPAREN param_list_opt RPAREN block
    (16) constructor_decl -> . mod ID LPAREN param_list_opt RPAREN block
    (17) mod -> . visibility_mod storage_mod
    (18) visibility_mod -> . PUBLIC
    (19) visibility_mod -> . PRIVATE
    (20) visibility_mod -> .

    error           shift and go to state 19
    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 12
    STATIC          reduce using rule 20 (visibility_mod -> .)
    VOID            reduce using rule 20 (visibility_mod -> .)
    ID              reduce using rule 20 (visibility_mod -> .)
    INT             reduce using rule 20 (visibility_mod -> .)
    BOOLEAN         reduce using rule 20 (visibility_mod -> .)
    FLOAT           reduce using rule 20 (visibility_mod -> .)

    class_body_decl                shift and go to state 14
    field_decl                     shift and go to state 17
    constructor_decl               shift and go to state 11
    method_decl                    shift and go to state 18
    visibility_mod                 shift and go to state 15
    class_body_decl_list           shift and go to state 13
    mod                            shift and go to state 16

state 10

    (6) extends -> EXTENDS ID .

    LBRACE          reduce using rule 6 (extends -> EXTENDS ID .)


state 11

    (12) class_body_decl -> constructor_decl .

    RBRACE          reduce using rule 12 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 12 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 12 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 12 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 12 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 12 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 12 (class_body_decl -> constructor_decl .)


state 12

    (19) visibility_mod -> PRIVATE .

    STATIC          reduce using rule 19 (visibility_mod -> PRIVATE .)
    VOID            reduce using rule 19 (visibility_mod -> PRIVATE .)
    ID              reduce using rule 19 (visibility_mod -> PRIVATE .)
    INT             reduce using rule 19 (visibility_mod -> PRIVATE .)
    BOOLEAN         reduce using rule 19 (visibility_mod -> PRIVATE .)
    FLOAT           reduce using rule 19 (visibility_mod -> PRIVATE .)


state 13

    (4) class_decl -> CLASS ID extends LBRACE class_body_decl_list . RBRACE
    (8) class_body_decl_list -> class_body_decl_list . class_body_decl
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . mod var_decl
    (14) method_decl -> . mod VOID ID LPAREN param_list_opt RPAREN block
    (15) method_decl -> . mod type ID LPAREN param_list_opt RPAREN block
    (16) constructor_decl -> . mod ID LPAREN param_list_opt RPAREN block
    (17) mod -> . visibility_mod storage_mod
    (18) visibility_mod -> . PUBLIC
    (19) visibility_mod -> . PRIVATE
    (20) visibility_mod -> .

    RBRACE          shift and go to state 22
    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 12
    STATIC          reduce using rule 20 (visibility_mod -> .)
    VOID            reduce using rule 20 (visibility_mod -> .)
    ID              reduce using rule 20 (visibility_mod -> .)
    INT             reduce using rule 20 (visibility_mod -> .)
    BOOLEAN         reduce using rule 20 (visibility_mod -> .)
    FLOAT           reduce using rule 20 (visibility_mod -> .)

    class_body_decl                shift and go to state 21
    field_decl                     shift and go to state 17
    constructor_decl               shift and go to state 11
    method_decl                    shift and go to state 18
    visibility_mod                 shift and go to state 15
    mod                            shift and go to state 16

state 14

    (9) class_body_decl_list -> class_body_decl .

    RBRACE          reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    VOID            reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    ID              reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    INT             reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    FLOAT           reduce using rule 9 (class_body_decl_list -> class_body_decl .)
    STATIC          reduce using rule 9 (class_body_decl_list -> class_body_decl .)


state 15

    (17) mod -> visibility_mod . storage_mod
    (21) storage_mod -> . STATIC
    (22) storage_mod -> .

    STATIC          shift and go to state 24
    VOID            reduce using rule 22 (storage_mod -> .)
    ID              reduce using rule 22 (storage_mod -> .)
    INT             reduce using rule 22 (storage_mod -> .)
    BOOLEAN         reduce using rule 22 (storage_mod -> .)
    FLOAT           reduce using rule 22 (storage_mod -> .)

    storage_mod                    shift and go to state 23

state 16

    (13) field_decl -> mod . var_decl
    (14) method_decl -> mod . VOID ID LPAREN param_list_opt RPAREN block
    (15) method_decl -> mod . type ID LPAREN param_list_opt RPAREN block
    (16) constructor_decl -> mod . ID LPAREN param_list_opt RPAREN block
    (23) var_decl -> . type var_list SEMICOLON
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    VOID            shift and go to state 26
    ID              shift and go to state 31
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27

    var_decl                       shift and go to state 29
    type                           shift and go to state 30

state 17

    (10) class_body_decl -> field_decl .

    RBRACE          reduce using rule 10 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 10 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> field_decl .)
    VOID            reduce using rule 10 (class_body_decl -> field_decl .)
    ID              reduce using rule 10 (class_body_decl -> field_decl .)
    INT             reduce using rule 10 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> field_decl .)


state 18

    (11) class_body_decl -> method_decl .

    RBRACE          reduce using rule 11 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 11 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> method_decl .)
    VOID            reduce using rule 11 (class_body_decl -> method_decl .)
    ID              reduce using rule 11 (class_body_decl -> method_decl .)
    INT             reduce using rule 11 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> method_decl .)


state 19

    (5) class_decl -> CLASS ID extends LBRACE error . RBRACE

    RBRACE          shift and go to state 32


state 20

    (18) visibility_mod -> PUBLIC .

    STATIC          reduce using rule 18 (visibility_mod -> PUBLIC .)
    VOID            reduce using rule 18 (visibility_mod -> PUBLIC .)
    ID              reduce using rule 18 (visibility_mod -> PUBLIC .)
    INT             reduce using rule 18 (visibility_mod -> PUBLIC .)
    BOOLEAN         reduce using rule 18 (visibility_mod -> PUBLIC .)
    FLOAT           reduce using rule 18 (visibility_mod -> PUBLIC .)


state 21

    (8) class_body_decl_list -> class_body_decl_list class_body_decl .

    RBRACE          reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    VOID            reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    ID              reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    INT             reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    FLOAT           reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    STATIC          reduce using rule 8 (class_body_decl_list -> class_body_decl_list class_body_decl .)


state 22

    (4) class_decl -> CLASS ID extends LBRACE class_body_decl_list RBRACE .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID extends LBRACE class_body_decl_list RBRACE .)
    $end            reduce using rule 4 (class_decl -> CLASS ID extends LBRACE class_body_decl_list RBRACE .)


state 23

    (17) mod -> visibility_mod storage_mod .

    VOID            reduce using rule 17 (mod -> visibility_mod storage_mod .)
    ID              reduce using rule 17 (mod -> visibility_mod storage_mod .)
    INT             reduce using rule 17 (mod -> visibility_mod storage_mod .)
    BOOLEAN         reduce using rule 17 (mod -> visibility_mod storage_mod .)
    FLOAT           reduce using rule 17 (mod -> visibility_mod storage_mod .)


state 24

    (21) storage_mod -> STATIC .

    VOID            reduce using rule 21 (storage_mod -> STATIC .)
    ID              reduce using rule 21 (storage_mod -> STATIC .)
    INT             reduce using rule 21 (storage_mod -> STATIC .)
    BOOLEAN         reduce using rule 21 (storage_mod -> STATIC .)
    FLOAT           reduce using rule 21 (storage_mod -> STATIC .)


state 25

    (24) type -> INT .

    LBRACKET        reduce using rule 24 (type -> INT .)
    ID              reduce using rule 24 (type -> INT .)


state 26

    (14) method_decl -> mod VOID . ID LPAREN param_list_opt RPAREN block

    ID              shift and go to state 33


state 27

    (26) type -> FLOAT .

    LBRACKET        reduce using rule 26 (type -> FLOAT .)
    ID              reduce using rule 26 (type -> FLOAT .)


state 28

    (25) type -> BOOLEAN .

    LBRACKET        reduce using rule 25 (type -> BOOLEAN .)
    ID              reduce using rule 25 (type -> BOOLEAN .)


state 29

    (13) field_decl -> mod var_decl .

    RBRACE          reduce using rule 13 (field_decl -> mod var_decl .)
    PUBLIC          reduce using rule 13 (field_decl -> mod var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> mod var_decl .)
    VOID            reduce using rule 13 (field_decl -> mod var_decl .)
    ID              reduce using rule 13 (field_decl -> mod var_decl .)
    INT             reduce using rule 13 (field_decl -> mod var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> mod var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> mod var_decl .)
    STATIC          reduce using rule 13 (field_decl -> mod var_decl .)


state 30

    (15) method_decl -> mod type . ID LPAREN param_list_opt RPAREN block
    (23) var_decl -> type . var_list SEMICOLON
    (28) var_list -> . var_list COMMA var
    (29) var_list -> . var
    (30) var -> . ID
    (31) var -> . var LBRACKET RBRACKET

    ID              shift and go to state 36

    var                            shift and go to state 34
    var_list                       shift and go to state 35

state 31

    (16) constructor_decl -> mod ID . LPAREN param_list_opt RPAREN block
    (27) type -> ID .

    LPAREN          shift and go to state 37
    ID              reduce using rule 27 (type -> ID .)


state 32

    (5) class_decl -> CLASS ID extends LBRACE error RBRACE .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID extends LBRACE error RBRACE .)
    $end            reduce using rule 5 (class_decl -> CLASS ID extends LBRACE error RBRACE .)


state 33

    (14) method_decl -> mod VOID ID . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 38


state 34

    (29) var_list -> var .
    (31) var -> var . LBRACKET RBRACKET

    SEMICOLON       reduce using rule 29 (var_list -> var .)
    COMMA           reduce using rule 29 (var_list -> var .)
    LBRACKET        shift and go to state 39


state 35

    (23) var_decl -> type var_list . SEMICOLON
    (28) var_list -> var_list . COMMA var

    SEMICOLON       shift and go to state 41
    COMMA           shift and go to state 40


state 36

    (15) method_decl -> mod type ID . LPAREN param_list_opt RPAREN block
    (30) var -> ID .

    LPAREN          shift and go to state 42
    LBRACKET        reduce using rule 30 (var -> ID .)
    SEMICOLON       reduce using rule 30 (var -> ID .)
    COMMA           reduce using rule 30 (var -> ID .)


state 37

    (16) constructor_decl -> mod ID LPAREN . param_list_opt RPAREN block
    (32) param_list_opt -> . param_list
    (33) param_list_opt -> .
    (34) param_list -> . param_list COMMA param
    (35) param_list -> . param
    (36) param -> . type ID
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    RPAREN          reduce using rule 33 (param_list_opt -> .)
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 47

    param_list                     shift and go to state 43
    param                          shift and go to state 45
    param_list_opt                 shift and go to state 44
    type                           shift and go to state 46

state 38

    (14) method_decl -> mod VOID ID LPAREN . param_list_opt RPAREN block
    (32) param_list_opt -> . param_list
    (33) param_list_opt -> .
    (34) param_list -> . param_list COMMA param
    (35) param_list -> . param
    (36) param -> . type ID
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    RPAREN          reduce using rule 33 (param_list_opt -> .)
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 47

    param_list                     shift and go to state 43
    param                          shift and go to state 45
    param_list_opt                 shift and go to state 48
    type                           shift and go to state 46

state 39

    (31) var -> var LBRACKET . RBRACKET

    RBRACKET        shift and go to state 49


state 40

    (28) var_list -> var_list COMMA . var
    (30) var -> . ID
    (31) var -> . var LBRACKET RBRACKET

    ID              shift and go to state 51

    var                            shift and go to state 50

state 41

    (23) var_decl -> type var_list SEMICOLON .

    RBRACE          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    error           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    IF              reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    WHILE           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    FOR             reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    RETURN          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    BREAK           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    CONTINUE        reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    LBRACE          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    INC             reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    DEC             reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    INT             reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    BOOLEAN         reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    FLOAT           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    ID              reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    THIS            reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    SUPER           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    LPAREN          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    NEW             reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    INT_CONST       reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    FLOAT_CONST     reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    STRING_CONST    reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    NULL            reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    TRUE            reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    FALSE           reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    ELSE            reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    PUBLIC          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    PRIVATE         reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    VOID            reduce using rule 23 (var_decl -> type var_list SEMICOLON .)
    STATIC          reduce using rule 23 (var_decl -> type var_list SEMICOLON .)


state 42

    (15) method_decl -> mod type ID LPAREN . param_list_opt RPAREN block
    (32) param_list_opt -> . param_list
    (33) param_list_opt -> .
    (34) param_list -> . param_list COMMA param
    (35) param_list -> . param
    (36) param -> . type ID
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    RPAREN          reduce using rule 33 (param_list_opt -> .)
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 47

    param_list                     shift and go to state 43
    param                          shift and go to state 45
    param_list_opt                 shift and go to state 52
    type                           shift and go to state 46

state 43

    (32) param_list_opt -> param_list .
    (34) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 32 (param_list_opt -> param_list .)
    COMMA           shift and go to state 53


state 44

    (16) constructor_decl -> mod ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 54


state 45

    (35) param_list -> param .

    COMMA           reduce using rule 35 (param_list -> param .)
    RPAREN          reduce using rule 35 (param_list -> param .)


state 46

    (36) param -> type . ID

    ID              shift and go to state 55


state 47

    (27) type -> ID .

    ID              reduce using rule 27 (type -> ID .)


state 48

    (14) method_decl -> mod VOID ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 56


state 49

    (31) var -> var LBRACKET RBRACKET .

    LBRACKET        reduce using rule 31 (var -> var LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 31 (var -> var LBRACKET RBRACKET .)
    COMMA           reduce using rule 31 (var -> var LBRACKET RBRACKET .)


state 50

    (28) var_list -> var_list COMMA var .
    (31) var -> var . LBRACKET RBRACKET

    SEMICOLON       reduce using rule 28 (var_list -> var_list COMMA var .)
    COMMA           reduce using rule 28 (var_list -> var_list COMMA var .)
    LBRACKET        shift and go to state 39


state 51

    (30) var -> ID .

    LBRACKET        reduce using rule 30 (var -> ID .)
    SEMICOLON       reduce using rule 30 (var -> ID .)
    COMMA           reduce using rule 30 (var -> ID .)


state 52

    (15) method_decl -> mod type ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 57


state 53

    (34) param_list -> param_list COMMA . param
    (36) param -> . type ID
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 47

    type                           shift and go to state 46
    param                          shift and go to state 58

state 54

    (16) constructor_decl -> mod ID LPAREN param_list_opt RPAREN . block
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE

    LBRACE          shift and go to state 59

    block                          shift and go to state 60

state 55

    (36) param -> type ID .

    COMMA           reduce using rule 36 (param -> type ID .)
    RPAREN          reduce using rule 36 (param -> type ID .)


state 56

    (14) method_decl -> mod VOID ID LPAREN param_list_opt RPAREN . block
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE

    LBRACE          shift and go to state 59

    block                          shift and go to state 61

state 57

    (15) method_decl -> mod type ID LPAREN param_list_opt RPAREN . block
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE

    LBRACE          shift and go to state 59

    block                          shift and go to state 62

state 58

    (34) param_list -> param_list COMMA param .

    COMMA           reduce using rule 34 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 34 (param_list -> param_list COMMA param .)


state 59

    (37) block -> LBRACE . stmt_list RBRACE
    (38) block -> LBRACE . stmt_list error RBRACE
    (39) stmt_list -> .
    (40) stmt_list -> . stmt_list stmt

    RBRACE          reduce using rule 39 (stmt_list -> .)
    error           reduce using rule 39 (stmt_list -> .)
    IF              reduce using rule 39 (stmt_list -> .)
    WHILE           reduce using rule 39 (stmt_list -> .)
    FOR             reduce using rule 39 (stmt_list -> .)
    RETURN          reduce using rule 39 (stmt_list -> .)
    BREAK           reduce using rule 39 (stmt_list -> .)
    CONTINUE        reduce using rule 39 (stmt_list -> .)
    LBRACE          reduce using rule 39 (stmt_list -> .)
    INC             reduce using rule 39 (stmt_list -> .)
    DEC             reduce using rule 39 (stmt_list -> .)
    INT             reduce using rule 39 (stmt_list -> .)
    BOOLEAN         reduce using rule 39 (stmt_list -> .)
    FLOAT           reduce using rule 39 (stmt_list -> .)
    ID              reduce using rule 39 (stmt_list -> .)
    THIS            reduce using rule 39 (stmt_list -> .)
    SUPER           reduce using rule 39 (stmt_list -> .)
    LPAREN          reduce using rule 39 (stmt_list -> .)
    NEW             reduce using rule 39 (stmt_list -> .)
    INT_CONST       reduce using rule 39 (stmt_list -> .)
    FLOAT_CONST     reduce using rule 39 (stmt_list -> .)
    STRING_CONST    reduce using rule 39 (stmt_list -> .)
    NULL            reduce using rule 39 (stmt_list -> .)
    TRUE            reduce using rule 39 (stmt_list -> .)
    FALSE           reduce using rule 39 (stmt_list -> .)

    stmt_list                      shift and go to state 63

state 60

    (16) constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .

    RBRACE          reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    PUBLIC          reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    PRIVATE         reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    VOID            reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    BOOLEAN         reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)
    STATIC          reduce using rule 16 (constructor_decl -> mod ID LPAREN param_list_opt RPAREN block .)


state 61

    (14) method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .

    RBRACE          reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    PUBLIC          reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    PRIVATE         reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    VOID            reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    BOOLEAN         reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)
    STATIC          reduce using rule 14 (method_decl -> mod VOID ID LPAREN param_list_opt RPAREN block .)


state 62

    (15) method_decl -> mod type ID LPAREN param_list_opt RPAREN block .

    RBRACE          reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    PUBLIC          reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    PRIVATE         reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    VOID            reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    BOOLEAN         reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)
    STATIC          reduce using rule 15 (method_decl -> mod type ID LPAREN param_list_opt RPAREN block .)


state 63

    (37) block -> LBRACE stmt_list . RBRACE
    (38) block -> LBRACE stmt_list . error RBRACE
    (40) stmt_list -> stmt_list . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (45) stmt -> . RETURN expr_opt SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . error SEMICOLON
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE
    (23) var_decl -> . type var_list SEMICOLON
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    RBRACE          shift and go to state 80
    error           shift and go to state 92
    IF              shift and go to state 85
    WHILE           shift and go to state 66
    FOR             shift and go to state 81
    RETURN          shift and go to state 64
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 90
    LBRACE          shift and go to state 59
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 84
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    array_access                   shift and go to state 70
    stmt_expr                      shift and go to state 75
    stmt                           shift and go to state 82
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    var_decl                       shift and go to state 87
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 64

    (45) stmt -> RETURN . expr_opt SEMICOLON
    (108) expr_opt -> . expr
    (109) expr_opt -> .
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    SEMICOLON       reduce using rule 109 (expr_opt -> .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 106
    primary                        shift and go to state 98
    array_access                   shift and go to state 70
    literal                        shift and go to state 76
    expr_opt                       shift and go to state 101
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 65

    (71) field_access -> primary . DOT ID
    (73) array_access -> primary . LBRACKET expr RBRACKET

    DOT             shift and go to state 111
    LBRACKET        shift and go to state 110


state 66

    (43) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 112


state 67

    (53) literal -> FLOAT_CONST .

    DOT             reduce using rule 53 (literal -> FLOAT_CONST .)
    LBRACKET        reduce using rule 53 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 53 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 53 (literal -> FLOAT_CONST .)
    MULTIPLY        reduce using rule 53 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 53 (literal -> FLOAT_CONST .)
    EQ              reduce using rule 53 (literal -> FLOAT_CONST .)
    NEQ             reduce using rule 53 (literal -> FLOAT_CONST .)
    LT              reduce using rule 53 (literal -> FLOAT_CONST .)
    LEQ             reduce using rule 53 (literal -> FLOAT_CONST .)
    GT              reduce using rule 53 (literal -> FLOAT_CONST .)
    GEQ             reduce using rule 53 (literal -> FLOAT_CONST .)
    AND             reduce using rule 53 (literal -> FLOAT_CONST .)
    OR              reduce using rule 53 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 53 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 53 (literal -> FLOAT_CONST .)
    RBRACKET        reduce using rule 53 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 53 (literal -> FLOAT_CONST .)


state 68

    (62) primary -> NEW . ID LPAREN args_opt RPAREN

    ID              shift and go to state 113


state 69

    (97) assign -> DEC . lhs
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN

    ID              shift and go to state 105
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 104
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 114
    method_invocation              shift and go to state 103
    array_access                   shift and go to state 70

state 70

    (70) lhs -> array_access .

    ASSIGN          reduce using rule 70 (lhs -> array_access .)
    INC             reduce using rule 70 (lhs -> array_access .)
    DEC             reduce using rule 70 (lhs -> array_access .)
    DOT             reduce using rule 70 (lhs -> array_access .)
    LBRACKET        reduce using rule 70 (lhs -> array_access .)
    RBRACKET        reduce using rule 70 (lhs -> array_access .)
    PLUS            reduce using rule 70 (lhs -> array_access .)
    MINUS           reduce using rule 70 (lhs -> array_access .)
    MULTIPLY        reduce using rule 70 (lhs -> array_access .)
    DIVIDE          reduce using rule 70 (lhs -> array_access .)
    EQ              reduce using rule 70 (lhs -> array_access .)
    NEQ             reduce using rule 70 (lhs -> array_access .)
    LT              reduce using rule 70 (lhs -> array_access .)
    LEQ             reduce using rule 70 (lhs -> array_access .)
    GT              reduce using rule 70 (lhs -> array_access .)
    GEQ             reduce using rule 70 (lhs -> array_access .)
    AND             reduce using rule 70 (lhs -> array_access .)
    OR              reduce using rule 70 (lhs -> array_access .)
    SEMICOLON       reduce using rule 70 (lhs -> array_access .)
    RPAREN          reduce using rule 70 (lhs -> array_access .)
    COMMA           reduce using rule 70 (lhs -> array_access .)


state 71

    (54) literal -> STRING_CONST .

    DOT             reduce using rule 54 (literal -> STRING_CONST .)
    LBRACKET        reduce using rule 54 (literal -> STRING_CONST .)
    PLUS            reduce using rule 54 (literal -> STRING_CONST .)
    MINUS           reduce using rule 54 (literal -> STRING_CONST .)
    MULTIPLY        reduce using rule 54 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 54 (literal -> STRING_CONST .)
    EQ              reduce using rule 54 (literal -> STRING_CONST .)
    NEQ             reduce using rule 54 (literal -> STRING_CONST .)
    LT              reduce using rule 54 (literal -> STRING_CONST .)
    LEQ             reduce using rule 54 (literal -> STRING_CONST .)
    GT              reduce using rule 54 (literal -> STRING_CONST .)
    GEQ             reduce using rule 54 (literal -> STRING_CONST .)
    AND             reduce using rule 54 (literal -> STRING_CONST .)
    OR              reduce using rule 54 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 54 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 54 (literal -> STRING_CONST .)
    RBRACKET        reduce using rule 54 (literal -> STRING_CONST .)
    COMMA           reduce using rule 54 (literal -> STRING_CONST .)


state 72

    (52) literal -> INT_CONST .

    DOT             reduce using rule 52 (literal -> INT_CONST .)
    LBRACKET        reduce using rule 52 (literal -> INT_CONST .)
    PLUS            reduce using rule 52 (literal -> INT_CONST .)
    MINUS           reduce using rule 52 (literal -> INT_CONST .)
    MULTIPLY        reduce using rule 52 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 52 (literal -> INT_CONST .)
    EQ              reduce using rule 52 (literal -> INT_CONST .)
    NEQ             reduce using rule 52 (literal -> INT_CONST .)
    LT              reduce using rule 52 (literal -> INT_CONST .)
    LEQ             reduce using rule 52 (literal -> INT_CONST .)
    GT              reduce using rule 52 (literal -> INT_CONST .)
    GEQ             reduce using rule 52 (literal -> INT_CONST .)
    AND             reduce using rule 52 (literal -> INT_CONST .)
    OR              reduce using rule 52 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 52 (literal -> INT_CONST .)
    RPAREN          reduce using rule 52 (literal -> INT_CONST .)
    RBRACKET        reduce using rule 52 (literal -> INT_CONST .)
    COMMA           reduce using rule 52 (literal -> INT_CONST .)


state 73

    (55) literal -> NULL .

    DOT             reduce using rule 55 (literal -> NULL .)
    LBRACKET        reduce using rule 55 (literal -> NULL .)
    PLUS            reduce using rule 55 (literal -> NULL .)
    MINUS           reduce using rule 55 (literal -> NULL .)
    MULTIPLY        reduce using rule 55 (literal -> NULL .)
    DIVIDE          reduce using rule 55 (literal -> NULL .)
    EQ              reduce using rule 55 (literal -> NULL .)
    NEQ             reduce using rule 55 (literal -> NULL .)
    LT              reduce using rule 55 (literal -> NULL .)
    LEQ             reduce using rule 55 (literal -> NULL .)
    GT              reduce using rule 55 (literal -> NULL .)
    GEQ             reduce using rule 55 (literal -> NULL .)
    AND             reduce using rule 55 (literal -> NULL .)
    OR              reduce using rule 55 (literal -> NULL .)
    SEMICOLON       reduce using rule 55 (literal -> NULL .)
    RPAREN          reduce using rule 55 (literal -> NULL .)
    RBRACKET        reduce using rule 55 (literal -> NULL .)
    COMMA           reduce using rule 55 (literal -> NULL .)


state 74

    (56) literal -> TRUE .

    DOT             reduce using rule 56 (literal -> TRUE .)
    LBRACKET        reduce using rule 56 (literal -> TRUE .)
    PLUS            reduce using rule 56 (literal -> TRUE .)
    MINUS           reduce using rule 56 (literal -> TRUE .)
    MULTIPLY        reduce using rule 56 (literal -> TRUE .)
    DIVIDE          reduce using rule 56 (literal -> TRUE .)
    EQ              reduce using rule 56 (literal -> TRUE .)
    NEQ             reduce using rule 56 (literal -> TRUE .)
    LT              reduce using rule 56 (literal -> TRUE .)
    LEQ             reduce using rule 56 (literal -> TRUE .)
    GT              reduce using rule 56 (literal -> TRUE .)
    GEQ             reduce using rule 56 (literal -> TRUE .)
    AND             reduce using rule 56 (literal -> TRUE .)
    OR              reduce using rule 56 (literal -> TRUE .)
    SEMICOLON       reduce using rule 56 (literal -> TRUE .)
    RPAREN          reduce using rule 56 (literal -> TRUE .)
    RBRACKET        reduce using rule 56 (literal -> TRUE .)
    COMMA           reduce using rule 56 (literal -> TRUE .)


state 75

    (46) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 115


state 76

    (58) primary -> literal .

    DOT             reduce using rule 58 (primary -> literal .)
    LBRACKET        reduce using rule 58 (primary -> literal .)
    PLUS            reduce using rule 58 (primary -> literal .)
    MINUS           reduce using rule 58 (primary -> literal .)
    MULTIPLY        reduce using rule 58 (primary -> literal .)
    DIVIDE          reduce using rule 58 (primary -> literal .)
    EQ              reduce using rule 58 (primary -> literal .)
    NEQ             reduce using rule 58 (primary -> literal .)
    LT              reduce using rule 58 (primary -> literal .)
    LEQ             reduce using rule 58 (primary -> literal .)
    GT              reduce using rule 58 (primary -> literal .)
    GEQ             reduce using rule 58 (primary -> literal .)
    AND             reduce using rule 58 (primary -> literal .)
    OR              reduce using rule 58 (primary -> literal .)
    COMMA           reduce using rule 58 (primary -> literal .)
    RPAREN          reduce using rule 58 (primary -> literal .)
    SEMICOLON       reduce using rule 58 (primary -> literal .)
    RBRACKET        reduce using rule 58 (primary -> literal .)


state 77

    (105) stmt_expr -> method_invocation .
    (64) primary -> method_invocation .

    SEMICOLON       reduce using rule 105 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 105 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 64 (primary -> method_invocation .)
    LBRACKET        reduce using rule 64 (primary -> method_invocation .)


state 78

    (23) var_decl -> type . var_list SEMICOLON
    (28) var_list -> . var_list COMMA var
    (29) var_list -> . var
    (30) var -> . ID
    (31) var -> . var LBRACKET RBRACKET

    ID              shift and go to state 51

    var                            shift and go to state 34
    var_list                       shift and go to state 35

state 79

    (74) method_invocation -> field_access . LPAREN args_opt RPAREN
    (69) lhs -> field_access .

    LPAREN          shift and go to state 116
    ASSIGN          reduce using rule 69 (lhs -> field_access .)
    INC             reduce using rule 69 (lhs -> field_access .)
    DEC             reduce using rule 69 (lhs -> field_access .)
    DOT             reduce using rule 69 (lhs -> field_access .)
    LBRACKET        reduce using rule 69 (lhs -> field_access .)


state 80

    (37) block -> LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    error           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    INC             reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    DEC             reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    INT             reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    THIS            reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    SUPER           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    NEW             reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    INT_CONST       reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    FLOAT_CONST     reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    STRING_CONST    reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    NULL            reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    PUBLIC          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    PRIVATE         reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)
    STATIC          reduce using rule 37 (block -> LBRACE stmt_list RBRACE .)


state 81

    (44) stmt -> FOR . LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt

    LPAREN          shift and go to state 117


state 82

    (40) stmt_list -> stmt_list stmt .

    RBRACE          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    error           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 40 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 40 (stmt_list -> stmt_list stmt .)
    LBRACE          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    INC             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    DEC             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    BOOLEAN         reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 40 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 40 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    LPAREN          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    INT_CONST       reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt_list -> stmt_list stmt .)
    STRING_CONST    reduce using rule 40 (stmt_list -> stmt_list stmt .)
    NULL            reduce using rule 40 (stmt_list -> stmt_list stmt .)
    TRUE            reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FALSE           reduce using rule 40 (stmt_list -> stmt_list stmt .)


state 83

    (61) primary -> LPAREN . expr RPAREN
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 118
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 84

    (27) type -> ID .
    (72) field_access -> ID .

    ID              reduce using rule 27 (type -> ID .)
    LPAREN          reduce using rule 72 (field_access -> ID .)
    ASSIGN          reduce using rule 72 (field_access -> ID .)
    INC             reduce using rule 72 (field_access -> ID .)
    DEC             reduce using rule 72 (field_access -> ID .)
    DOT             reduce using rule 72 (field_access -> ID .)
    LBRACKET        reduce using rule 72 (field_access -> ID .)


state 85

    (41) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> IF . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 119


state 86

    (57) literal -> FALSE .

    DOT             reduce using rule 57 (literal -> FALSE .)
    LBRACKET        reduce using rule 57 (literal -> FALSE .)
    PLUS            reduce using rule 57 (literal -> FALSE .)
    MINUS           reduce using rule 57 (literal -> FALSE .)
    MULTIPLY        reduce using rule 57 (literal -> FALSE .)
    DIVIDE          reduce using rule 57 (literal -> FALSE .)
    EQ              reduce using rule 57 (literal -> FALSE .)
    NEQ             reduce using rule 57 (literal -> FALSE .)
    LT              reduce using rule 57 (literal -> FALSE .)
    LEQ             reduce using rule 57 (literal -> FALSE .)
    GT              reduce using rule 57 (literal -> FALSE .)
    GEQ             reduce using rule 57 (literal -> FALSE .)
    AND             reduce using rule 57 (literal -> FALSE .)
    OR              reduce using rule 57 (literal -> FALSE .)
    SEMICOLON       reduce using rule 57 (literal -> FALSE .)
    RPAREN          reduce using rule 57 (literal -> FALSE .)
    RBRACKET        reduce using rule 57 (literal -> FALSE .)
    COMMA           reduce using rule 57 (literal -> FALSE .)


state 87

    (50) stmt -> var_decl .

    RBRACE          reduce using rule 50 (stmt -> var_decl .)
    error           reduce using rule 50 (stmt -> var_decl .)
    IF              reduce using rule 50 (stmt -> var_decl .)
    WHILE           reduce using rule 50 (stmt -> var_decl .)
    FOR             reduce using rule 50 (stmt -> var_decl .)
    RETURN          reduce using rule 50 (stmt -> var_decl .)
    BREAK           reduce using rule 50 (stmt -> var_decl .)
    CONTINUE        reduce using rule 50 (stmt -> var_decl .)
    LBRACE          reduce using rule 50 (stmt -> var_decl .)
    INC             reduce using rule 50 (stmt -> var_decl .)
    DEC             reduce using rule 50 (stmt -> var_decl .)
    INT             reduce using rule 50 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 50 (stmt -> var_decl .)
    FLOAT           reduce using rule 50 (stmt -> var_decl .)
    ID              reduce using rule 50 (stmt -> var_decl .)
    THIS            reduce using rule 50 (stmt -> var_decl .)
    SUPER           reduce using rule 50 (stmt -> var_decl .)
    LPAREN          reduce using rule 50 (stmt -> var_decl .)
    NEW             reduce using rule 50 (stmt -> var_decl .)
    INT_CONST       reduce using rule 50 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 50 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 50 (stmt -> var_decl .)
    NULL            reduce using rule 50 (stmt -> var_decl .)
    TRUE            reduce using rule 50 (stmt -> var_decl .)
    FALSE           reduce using rule 50 (stmt -> var_decl .)
    ELSE            reduce using rule 50 (stmt -> var_decl .)


state 88

    (47) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 120


state 89

    (59) primary -> THIS .

    DOT             reduce using rule 59 (primary -> THIS .)
    LBRACKET        reduce using rule 59 (primary -> THIS .)
    PLUS            reduce using rule 59 (primary -> THIS .)
    MINUS           reduce using rule 59 (primary -> THIS .)
    MULTIPLY        reduce using rule 59 (primary -> THIS .)
    DIVIDE          reduce using rule 59 (primary -> THIS .)
    EQ              reduce using rule 59 (primary -> THIS .)
    NEQ             reduce using rule 59 (primary -> THIS .)
    LT              reduce using rule 59 (primary -> THIS .)
    LEQ             reduce using rule 59 (primary -> THIS .)
    GT              reduce using rule 59 (primary -> THIS .)
    GEQ             reduce using rule 59 (primary -> THIS .)
    AND             reduce using rule 59 (primary -> THIS .)
    OR              reduce using rule 59 (primary -> THIS .)
    COMMA           reduce using rule 59 (primary -> THIS .)
    RPAREN          reduce using rule 59 (primary -> THIS .)
    SEMICOLON       reduce using rule 59 (primary -> THIS .)
    RBRACKET        reduce using rule 59 (primary -> THIS .)


state 90

    (48) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 121


state 91

    (93) assign -> lhs . ASSIGN expr
    (94) assign -> lhs . INC
    (96) assign -> lhs . DEC
    (63) primary -> lhs .

    ASSIGN          shift and go to state 123
    INC             shift and go to state 124
    DEC             shift and go to state 122
    DOT             reduce using rule 63 (primary -> lhs .)
    LBRACKET        reduce using rule 63 (primary -> lhs .)


state 92

    (38) block -> LBRACE stmt_list error . RBRACE
    (51) stmt -> error . SEMICOLON

    RBRACE          shift and go to state 125
    SEMICOLON       shift and go to state 126


state 93

    (60) primary -> SUPER .

    DOT             reduce using rule 60 (primary -> SUPER .)
    LBRACKET        reduce using rule 60 (primary -> SUPER .)
    PLUS            reduce using rule 60 (primary -> SUPER .)
    MINUS           reduce using rule 60 (primary -> SUPER .)
    MULTIPLY        reduce using rule 60 (primary -> SUPER .)
    DIVIDE          reduce using rule 60 (primary -> SUPER .)
    EQ              reduce using rule 60 (primary -> SUPER .)
    NEQ             reduce using rule 60 (primary -> SUPER .)
    LT              reduce using rule 60 (primary -> SUPER .)
    LEQ             reduce using rule 60 (primary -> SUPER .)
    GT              reduce using rule 60 (primary -> SUPER .)
    GEQ             reduce using rule 60 (primary -> SUPER .)
    AND             reduce using rule 60 (primary -> SUPER .)
    OR              reduce using rule 60 (primary -> SUPER .)
    COMMA           reduce using rule 60 (primary -> SUPER .)
    RPAREN          reduce using rule 60 (primary -> SUPER .)
    SEMICOLON       reduce using rule 60 (primary -> SUPER .)
    RBRACKET        reduce using rule 60 (primary -> SUPER .)


state 94

    (104) stmt_expr -> assign .

    SEMICOLON       reduce using rule 104 (stmt_expr -> assign .)
    RPAREN          reduce using rule 104 (stmt_expr -> assign .)


state 95

    (49) stmt -> block .

    RBRACE          reduce using rule 49 (stmt -> block .)
    error           reduce using rule 49 (stmt -> block .)
    IF              reduce using rule 49 (stmt -> block .)
    WHILE           reduce using rule 49 (stmt -> block .)
    FOR             reduce using rule 49 (stmt -> block .)
    RETURN          reduce using rule 49 (stmt -> block .)
    BREAK           reduce using rule 49 (stmt -> block .)
    CONTINUE        reduce using rule 49 (stmt -> block .)
    LBRACE          reduce using rule 49 (stmt -> block .)
    INC             reduce using rule 49 (stmt -> block .)
    DEC             reduce using rule 49 (stmt -> block .)
    INT             reduce using rule 49 (stmt -> block .)
    BOOLEAN         reduce using rule 49 (stmt -> block .)
    FLOAT           reduce using rule 49 (stmt -> block .)
    ID              reduce using rule 49 (stmt -> block .)
    THIS            reduce using rule 49 (stmt -> block .)
    SUPER           reduce using rule 49 (stmt -> block .)
    LPAREN          reduce using rule 49 (stmt -> block .)
    NEW             reduce using rule 49 (stmt -> block .)
    INT_CONST       reduce using rule 49 (stmt -> block .)
    FLOAT_CONST     reduce using rule 49 (stmt -> block .)
    STRING_CONST    reduce using rule 49 (stmt -> block .)
    NULL            reduce using rule 49 (stmt -> block .)
    TRUE            reduce using rule 49 (stmt -> block .)
    FALSE           reduce using rule 49 (stmt -> block .)
    ELSE            reduce using rule 49 (stmt -> block .)


state 96

    (95) assign -> INC . lhs
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN

    ID              shift and go to state 105
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 104
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 127
    method_invocation              shift and go to state 103
    array_access                   shift and go to state 70

state 97

    (77) expr -> new_array .

    PLUS            reduce using rule 77 (expr -> new_array .)
    MINUS           reduce using rule 77 (expr -> new_array .)
    MULTIPLY        reduce using rule 77 (expr -> new_array .)
    DIVIDE          reduce using rule 77 (expr -> new_array .)
    EQ              reduce using rule 77 (expr -> new_array .)
    NEQ             reduce using rule 77 (expr -> new_array .)
    LT              reduce using rule 77 (expr -> new_array .)
    LEQ             reduce using rule 77 (expr -> new_array .)
    GT              reduce using rule 77 (expr -> new_array .)
    GEQ             reduce using rule 77 (expr -> new_array .)
    AND             reduce using rule 77 (expr -> new_array .)
    OR              reduce using rule 77 (expr -> new_array .)
    SEMICOLON       reduce using rule 77 (expr -> new_array .)
    RPAREN          reduce using rule 77 (expr -> new_array .)
    RBRACKET        reduce using rule 77 (expr -> new_array .)
    COMMA           reduce using rule 77 (expr -> new_array .)


state 98

    (75) expr -> primary .
    (71) field_access -> primary . DOT ID
    (73) array_access -> primary . LBRACKET expr RBRACKET

    PLUS            reduce using rule 75 (expr -> primary .)
    MINUS           reduce using rule 75 (expr -> primary .)
    MULTIPLY        reduce using rule 75 (expr -> primary .)
    DIVIDE          reduce using rule 75 (expr -> primary .)
    EQ              reduce using rule 75 (expr -> primary .)
    NEQ             reduce using rule 75 (expr -> primary .)
    LT              reduce using rule 75 (expr -> primary .)
    LEQ             reduce using rule 75 (expr -> primary .)
    GT              reduce using rule 75 (expr -> primary .)
    GEQ             reduce using rule 75 (expr -> primary .)
    AND             reduce using rule 75 (expr -> primary .)
    OR              reduce using rule 75 (expr -> primary .)
    SEMICOLON       reduce using rule 75 (expr -> primary .)
    RPAREN          reduce using rule 75 (expr -> primary .)
    RBRACKET        reduce using rule 75 (expr -> primary .)
    COMMA           reduce using rule 75 (expr -> primary .)
    DOT             shift and go to state 111
    LBRACKET        shift and go to state 110


state 99

    (62) primary -> NEW . ID LPAREN args_opt RPAREN
    (98) new_array -> NEW . type dim_expr_plus dim_star
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID

    ID              shift and go to state 129
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27

    type                           shift and go to state 128

state 100

    (91) expr -> MINUS . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 130
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 101

    (45) stmt -> RETURN expr_opt . SEMICOLON

    SEMICOLON       shift and go to state 131


state 102

    (90) expr -> PLUS . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 132
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 103

    (64) primary -> method_invocation .

    DOT             reduce using rule 64 (primary -> method_invocation .)
    LBRACKET        reduce using rule 64 (primary -> method_invocation .)
    PLUS            reduce using rule 64 (primary -> method_invocation .)
    MINUS           reduce using rule 64 (primary -> method_invocation .)
    MULTIPLY        reduce using rule 64 (primary -> method_invocation .)
    DIVIDE          reduce using rule 64 (primary -> method_invocation .)
    EQ              reduce using rule 64 (primary -> method_invocation .)
    NEQ             reduce using rule 64 (primary -> method_invocation .)
    LT              reduce using rule 64 (primary -> method_invocation .)
    LEQ             reduce using rule 64 (primary -> method_invocation .)
    GT              reduce using rule 64 (primary -> method_invocation .)
    GEQ             reduce using rule 64 (primary -> method_invocation .)
    AND             reduce using rule 64 (primary -> method_invocation .)
    OR              reduce using rule 64 (primary -> method_invocation .)
    COMMA           reduce using rule 64 (primary -> method_invocation .)
    RPAREN          reduce using rule 64 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 64 (primary -> method_invocation .)
    RBRACKET        reduce using rule 64 (primary -> method_invocation .)


state 104

    (69) lhs -> field_access .
    (74) method_invocation -> field_access . LPAREN args_opt RPAREN

    ASSIGN          reduce using rule 69 (lhs -> field_access .)
    INC             reduce using rule 69 (lhs -> field_access .)
    DEC             reduce using rule 69 (lhs -> field_access .)
    DOT             reduce using rule 69 (lhs -> field_access .)
    LBRACKET        reduce using rule 69 (lhs -> field_access .)
    RBRACKET        reduce using rule 69 (lhs -> field_access .)
    PLUS            reduce using rule 69 (lhs -> field_access .)
    MINUS           reduce using rule 69 (lhs -> field_access .)
    MULTIPLY        reduce using rule 69 (lhs -> field_access .)
    DIVIDE          reduce using rule 69 (lhs -> field_access .)
    EQ              reduce using rule 69 (lhs -> field_access .)
    NEQ             reduce using rule 69 (lhs -> field_access .)
    LT              reduce using rule 69 (lhs -> field_access .)
    LEQ             reduce using rule 69 (lhs -> field_access .)
    GT              reduce using rule 69 (lhs -> field_access .)
    GEQ             reduce using rule 69 (lhs -> field_access .)
    AND             reduce using rule 69 (lhs -> field_access .)
    OR              reduce using rule 69 (lhs -> field_access .)
    SEMICOLON       reduce using rule 69 (lhs -> field_access .)
    RPAREN          reduce using rule 69 (lhs -> field_access .)
    COMMA           reduce using rule 69 (lhs -> field_access .)
    LPAREN          shift and go to state 116


state 105

    (72) field_access -> ID .

    LPAREN          reduce using rule 72 (field_access -> ID .)
    ASSIGN          reduce using rule 72 (field_access -> ID .)
    INC             reduce using rule 72 (field_access -> ID .)
    DEC             reduce using rule 72 (field_access -> ID .)
    DOT             reduce using rule 72 (field_access -> ID .)
    LBRACKET        reduce using rule 72 (field_access -> ID .)
    RPAREN          reduce using rule 72 (field_access -> ID .)
    PLUS            reduce using rule 72 (field_access -> ID .)
    MINUS           reduce using rule 72 (field_access -> ID .)
    MULTIPLY        reduce using rule 72 (field_access -> ID .)
    DIVIDE          reduce using rule 72 (field_access -> ID .)
    EQ              reduce using rule 72 (field_access -> ID .)
    NEQ             reduce using rule 72 (field_access -> ID .)
    LT              reduce using rule 72 (field_access -> ID .)
    LEQ             reduce using rule 72 (field_access -> ID .)
    GT              reduce using rule 72 (field_access -> ID .)
    GEQ             reduce using rule 72 (field_access -> ID .)
    AND             reduce using rule 72 (field_access -> ID .)
    OR              reduce using rule 72 (field_access -> ID .)
    SEMICOLON       reduce using rule 72 (field_access -> ID .)
    RBRACKET        reduce using rule 72 (field_access -> ID .)
    COMMA           reduce using rule 72 (field_access -> ID .)


state 106

    (108) expr_opt -> expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    SEMICOLON       reduce using rule 108 (expr_opt -> expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 107

    (76) expr -> assign .

    PLUS            reduce using rule 76 (expr -> assign .)
    MINUS           reduce using rule 76 (expr -> assign .)
    MULTIPLY        reduce using rule 76 (expr -> assign .)
    DIVIDE          reduce using rule 76 (expr -> assign .)
    EQ              reduce using rule 76 (expr -> assign .)
    NEQ             reduce using rule 76 (expr -> assign .)
    LT              reduce using rule 76 (expr -> assign .)
    LEQ             reduce using rule 76 (expr -> assign .)
    GT              reduce using rule 76 (expr -> assign .)
    GEQ             reduce using rule 76 (expr -> assign .)
    AND             reduce using rule 76 (expr -> assign .)
    OR              reduce using rule 76 (expr -> assign .)
    SEMICOLON       reduce using rule 76 (expr -> assign .)
    RPAREN          reduce using rule 76 (expr -> assign .)
    RBRACKET        reduce using rule 76 (expr -> assign .)
    COMMA           reduce using rule 76 (expr -> assign .)


state 108

    (63) primary -> lhs .
    (93) assign -> lhs . ASSIGN expr
    (94) assign -> lhs . INC
    (96) assign -> lhs . DEC

    DOT             reduce using rule 63 (primary -> lhs .)
    LBRACKET        reduce using rule 63 (primary -> lhs .)
    PLUS            reduce using rule 63 (primary -> lhs .)
    MINUS           reduce using rule 63 (primary -> lhs .)
    MULTIPLY        reduce using rule 63 (primary -> lhs .)
    DIVIDE          reduce using rule 63 (primary -> lhs .)
    EQ              reduce using rule 63 (primary -> lhs .)
    NEQ             reduce using rule 63 (primary -> lhs .)
    LT              reduce using rule 63 (primary -> lhs .)
    LEQ             reduce using rule 63 (primary -> lhs .)
    GT              reduce using rule 63 (primary -> lhs .)
    GEQ             reduce using rule 63 (primary -> lhs .)
    AND             reduce using rule 63 (primary -> lhs .)
    OR              reduce using rule 63 (primary -> lhs .)
    COMMA           reduce using rule 63 (primary -> lhs .)
    RPAREN          reduce using rule 63 (primary -> lhs .)
    SEMICOLON       reduce using rule 63 (primary -> lhs .)
    RBRACKET        reduce using rule 63 (primary -> lhs .)
    ASSIGN          shift and go to state 123
    INC             shift and go to state 124
    DEC             shift and go to state 122


state 109

    (92) expr -> NOT . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 145
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 110

    (73) array_access -> primary LBRACKET . expr RBRACKET
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 146
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 111

    (71) field_access -> primary DOT . ID

    ID              shift and go to state 147


state 112

    (43) stmt -> WHILE LPAREN . expr RPAREN stmt
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 148
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    array_access                   shift and go to state 70
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 113

    (62) primary -> NEW ID . LPAREN args_opt RPAREN

    LPAREN          shift and go to state 149


state 114

    (97) assign -> DEC lhs .
    (63) primary -> lhs .

    RBRACKET        reduce using rule 97 (assign -> DEC lhs .)
    PLUS            reduce using rule 97 (assign -> DEC lhs .)
    MINUS           reduce using rule 97 (assign -> DEC lhs .)
    MULTIPLY        reduce using rule 97 (assign -> DEC lhs .)
    DIVIDE          reduce using rule 97 (assign -> DEC lhs .)
    EQ              reduce using rule 97 (assign -> DEC lhs .)
    NEQ             reduce using rule 97 (assign -> DEC lhs .)
    LT              reduce using rule 97 (assign -> DEC lhs .)
    LEQ             reduce using rule 97 (assign -> DEC lhs .)
    GT              reduce using rule 97 (assign -> DEC lhs .)
    GEQ             reduce using rule 97 (assign -> DEC lhs .)
    AND             reduce using rule 97 (assign -> DEC lhs .)
    OR              reduce using rule 97 (assign -> DEC lhs .)
    COMMA           reduce using rule 97 (assign -> DEC lhs .)
    RPAREN          reduce using rule 97 (assign -> DEC lhs .)
    SEMICOLON       reduce using rule 97 (assign -> DEC lhs .)
    DOT             reduce using rule 63 (primary -> lhs .)
    LBRACKET        reduce using rule 63 (primary -> lhs .)


state 115

    (46) stmt -> stmt_expr SEMICOLON .

    RBRACE          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    error           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    LBRACE          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    INC             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    DEC             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)


state 116

    (74) method_invocation -> field_access LPAREN . args_opt RPAREN
    (65) args_opt -> . arg_plus
    (66) args_opt -> .
    (67) arg_plus -> . arg_plus COMMA expr
    (68) arg_plus -> . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    RPAREN          reduce using rule 66 (args_opt -> .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    field_access                   shift and go to state 104
    new_array                      shift and go to state 97
    expr                           shift and go to state 150
    primary                        shift and go to state 98
    array_access                   shift and go to state 70
    args_opt                       shift and go to state 151
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    arg_plus                       shift and go to state 152
    assign                         shift and go to state 107

state 117

    (44) stmt -> FOR LPAREN . stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (106) stmt_expr_opt -> . stmt_expr
    (107) stmt_expr_opt -> .
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    SEMICOLON       reduce using rule 107 (stmt_expr_opt -> .)
    INC             shift and go to state 96
    DEC             shift and go to state 69
    ID              shift and go to state 105
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    primary                        shift and go to state 65
    stmt_expr_opt                  shift and go to state 154
    stmt_expr                      shift and go to state 153
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    method_invocation              shift and go to state 77
    array_access                   shift and go to state 70
    assign                         shift and go to state 94

state 118

    (61) primary -> LPAREN expr . RPAREN
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RPAREN          shift and go to state 155
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 119

    (41) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (42) stmt -> IF LPAREN . expr RPAREN stmt
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 156
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    array_access                   shift and go to state 70
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 120

    (47) stmt -> BREAK SEMICOLON .

    RBRACE          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    error           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    INC             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    DEC             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> BREAK SEMICOLON .)


state 121

    (48) stmt -> CONTINUE SEMICOLON .

    RBRACE          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    error           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    INC             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)


state 122

    (96) assign -> lhs DEC .

    RBRACKET        reduce using rule 96 (assign -> lhs DEC .)
    PLUS            reduce using rule 96 (assign -> lhs DEC .)
    MINUS           reduce using rule 96 (assign -> lhs DEC .)
    MULTIPLY        reduce using rule 96 (assign -> lhs DEC .)
    DIVIDE          reduce using rule 96 (assign -> lhs DEC .)
    EQ              reduce using rule 96 (assign -> lhs DEC .)
    NEQ             reduce using rule 96 (assign -> lhs DEC .)
    LT              reduce using rule 96 (assign -> lhs DEC .)
    LEQ             reduce using rule 96 (assign -> lhs DEC .)
    GT              reduce using rule 96 (assign -> lhs DEC .)
    GEQ             reduce using rule 96 (assign -> lhs DEC .)
    AND             reduce using rule 96 (assign -> lhs DEC .)
    OR              reduce using rule 96 (assign -> lhs DEC .)
    COMMA           reduce using rule 96 (assign -> lhs DEC .)
    RPAREN          reduce using rule 96 (assign -> lhs DEC .)
    SEMICOLON       reduce using rule 96 (assign -> lhs DEC .)


state 123

    (93) assign -> lhs ASSIGN . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 157
    primary                        shift and go to state 98
    array_access                   shift and go to state 70
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 124

    (94) assign -> lhs INC .

    RBRACKET        reduce using rule 94 (assign -> lhs INC .)
    PLUS            reduce using rule 94 (assign -> lhs INC .)
    MINUS           reduce using rule 94 (assign -> lhs INC .)
    MULTIPLY        reduce using rule 94 (assign -> lhs INC .)
    DIVIDE          reduce using rule 94 (assign -> lhs INC .)
    EQ              reduce using rule 94 (assign -> lhs INC .)
    NEQ             reduce using rule 94 (assign -> lhs INC .)
    LT              reduce using rule 94 (assign -> lhs INC .)
    LEQ             reduce using rule 94 (assign -> lhs INC .)
    GT              reduce using rule 94 (assign -> lhs INC .)
    GEQ             reduce using rule 94 (assign -> lhs INC .)
    AND             reduce using rule 94 (assign -> lhs INC .)
    OR              reduce using rule 94 (assign -> lhs INC .)
    COMMA           reduce using rule 94 (assign -> lhs INC .)
    RPAREN          reduce using rule 94 (assign -> lhs INC .)
    SEMICOLON       reduce using rule 94 (assign -> lhs INC .)


state 125

    (38) block -> LBRACE stmt_list error RBRACE .

    RBRACE          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    error           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    IF              reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    WHILE           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    FOR             reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    RETURN          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    BREAK           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    CONTINUE        reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    LBRACE          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    INC             reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    DEC             reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    INT             reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    BOOLEAN         reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    FLOAT           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    ID              reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    THIS            reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    SUPER           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    LPAREN          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    NEW             reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    INT_CONST       reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    FLOAT_CONST     reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    STRING_CONST    reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    NULL            reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    TRUE            reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    FALSE           reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    ELSE            reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    PUBLIC          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    PRIVATE         reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    VOID            reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)
    STATIC          reduce using rule 38 (block -> LBRACE stmt_list error RBRACE .)


state 126

    (51) stmt -> error SEMICOLON .

    RBRACE          reduce using rule 51 (stmt -> error SEMICOLON .)
    error           reduce using rule 51 (stmt -> error SEMICOLON .)
    IF              reduce using rule 51 (stmt -> error SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> error SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> error SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> error SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> error SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> error SEMICOLON .)
    LBRACE          reduce using rule 51 (stmt -> error SEMICOLON .)
    INC             reduce using rule 51 (stmt -> error SEMICOLON .)
    DEC             reduce using rule 51 (stmt -> error SEMICOLON .)
    INT             reduce using rule 51 (stmt -> error SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> error SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> error SEMICOLON .)
    ID              reduce using rule 51 (stmt -> error SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> error SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> error SEMICOLON .)
    LPAREN          reduce using rule 51 (stmt -> error SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> error SEMICOLON .)
    INT_CONST       reduce using rule 51 (stmt -> error SEMICOLON .)
    FLOAT_CONST     reduce using rule 51 (stmt -> error SEMICOLON .)
    STRING_CONST    reduce using rule 51 (stmt -> error SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> error SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> error SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> error SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> error SEMICOLON .)


state 127

    (95) assign -> INC lhs .
    (63) primary -> lhs .

    RBRACKET        reduce using rule 95 (assign -> INC lhs .)
    PLUS            reduce using rule 95 (assign -> INC lhs .)
    MINUS           reduce using rule 95 (assign -> INC lhs .)
    MULTIPLY        reduce using rule 95 (assign -> INC lhs .)
    DIVIDE          reduce using rule 95 (assign -> INC lhs .)
    EQ              reduce using rule 95 (assign -> INC lhs .)
    NEQ             reduce using rule 95 (assign -> INC lhs .)
    LT              reduce using rule 95 (assign -> INC lhs .)
    LEQ             reduce using rule 95 (assign -> INC lhs .)
    GT              reduce using rule 95 (assign -> INC lhs .)
    GEQ             reduce using rule 95 (assign -> INC lhs .)
    AND             reduce using rule 95 (assign -> INC lhs .)
    OR              reduce using rule 95 (assign -> INC lhs .)
    COMMA           reduce using rule 95 (assign -> INC lhs .)
    RPAREN          reduce using rule 95 (assign -> INC lhs .)
    SEMICOLON       reduce using rule 95 (assign -> INC lhs .)
    DOT             reduce using rule 63 (primary -> lhs .)
    LBRACKET        reduce using rule 63 (primary -> lhs .)


state 128

    (98) new_array -> NEW type . dim_expr_plus dim_star
    (99) dim_expr_plus -> . dim_expr_plus dim_expr
    (100) dim_expr_plus -> . dim_expr
    (101) dim_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 160

    dim_expr                       shift and go to state 159
    dim_expr_plus                  shift and go to state 158

state 129

    (62) primary -> NEW ID . LPAREN args_opt RPAREN
    (27) type -> ID .

    LPAREN          shift and go to state 149
    LBRACKET        reduce using rule 27 (type -> ID .)


state 130

    (91) expr -> MINUS expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 91 (expr -> MINUS expr .)
    MINUS           reduce using rule 91 (expr -> MINUS expr .)
    MULTIPLY        reduce using rule 91 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 91 (expr -> MINUS expr .)
    EQ              reduce using rule 91 (expr -> MINUS expr .)
    NEQ             reduce using rule 91 (expr -> MINUS expr .)
    LT              reduce using rule 91 (expr -> MINUS expr .)
    LEQ             reduce using rule 91 (expr -> MINUS expr .)
    GT              reduce using rule 91 (expr -> MINUS expr .)
    GEQ             reduce using rule 91 (expr -> MINUS expr .)
    AND             reduce using rule 91 (expr -> MINUS expr .)
    OR              reduce using rule 91 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 91 (expr -> MINUS expr .)
    RPAREN          reduce using rule 91 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 91 (expr -> MINUS expr .)
    COMMA           reduce using rule 91 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 136 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 131

    (45) stmt -> RETURN expr_opt SEMICOLON .

    RBRACE          reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    error           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    IF              reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    LBRACE          reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    INC             reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    DEC             reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    INT             reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    ID              reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    INT_CONST       reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    FLOAT_CONST     reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    STRING_CONST    reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> RETURN expr_opt SEMICOLON .)


state 132

    (90) expr -> PLUS expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 90 (expr -> PLUS expr .)
    MINUS           reduce using rule 90 (expr -> PLUS expr .)
    MULTIPLY        reduce using rule 90 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 90 (expr -> PLUS expr .)
    EQ              reduce using rule 90 (expr -> PLUS expr .)
    NEQ             reduce using rule 90 (expr -> PLUS expr .)
    LT              reduce using rule 90 (expr -> PLUS expr .)
    LEQ             reduce using rule 90 (expr -> PLUS expr .)
    GT              reduce using rule 90 (expr -> PLUS expr .)
    GEQ             reduce using rule 90 (expr -> PLUS expr .)
    AND             reduce using rule 90 (expr -> PLUS expr .)
    OR              reduce using rule 90 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 90 (expr -> PLUS expr .)
    RPAREN          reduce using rule 90 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 90 (expr -> PLUS expr .)
    COMMA           reduce using rule 90 (expr -> PLUS expr .)

  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 136 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 133

    (88) expr -> expr AND . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 161
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 134

    (87) expr -> expr GEQ . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 162
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 135

    (86) expr -> expr GT . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 163
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 136

    (81) expr -> expr DIVIDE . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 164
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 137

    (89) expr -> expr OR . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 165
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 138

    (85) expr -> expr LEQ . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 166
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 139

    (84) expr -> expr LT . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 167
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 140

    (78) expr -> expr PLUS . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 168
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 141

    (80) expr -> expr MULTIPLY . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 169
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 142

    (82) expr -> expr EQ . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 170
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 143

    (79) expr -> expr MINUS . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 171
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 144

    (83) expr -> expr NEQ . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 172
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 145

    (92) expr -> NOT expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 92 (expr -> NOT expr .)
    MINUS           reduce using rule 92 (expr -> NOT expr .)
    MULTIPLY        reduce using rule 92 (expr -> NOT expr .)
    DIVIDE          reduce using rule 92 (expr -> NOT expr .)
    EQ              reduce using rule 92 (expr -> NOT expr .)
    NEQ             reduce using rule 92 (expr -> NOT expr .)
    LT              reduce using rule 92 (expr -> NOT expr .)
    LEQ             reduce using rule 92 (expr -> NOT expr .)
    GT              reduce using rule 92 (expr -> NOT expr .)
    GEQ             reduce using rule 92 (expr -> NOT expr .)
    AND             reduce using rule 92 (expr -> NOT expr .)
    OR              reduce using rule 92 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 92 (expr -> NOT expr .)
    RPAREN          reduce using rule 92 (expr -> NOT expr .)
    RBRACKET        reduce using rule 92 (expr -> NOT expr .)
    COMMA           reduce using rule 92 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 136 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 146

    (73) array_access -> primary LBRACKET expr . RBRACKET
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RBRACKET        shift and go to state 173
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 147

    (71) field_access -> primary DOT ID .

    LPAREN          reduce using rule 71 (field_access -> primary DOT ID .)
    ASSIGN          reduce using rule 71 (field_access -> primary DOT ID .)
    INC             reduce using rule 71 (field_access -> primary DOT ID .)
    DEC             reduce using rule 71 (field_access -> primary DOT ID .)
    DOT             reduce using rule 71 (field_access -> primary DOT ID .)
    LBRACKET        reduce using rule 71 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 71 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 71 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 71 (field_access -> primary DOT ID .)
    MULTIPLY        reduce using rule 71 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 71 (field_access -> primary DOT ID .)
    EQ              reduce using rule 71 (field_access -> primary DOT ID .)
    NEQ             reduce using rule 71 (field_access -> primary DOT ID .)
    LT              reduce using rule 71 (field_access -> primary DOT ID .)
    LEQ             reduce using rule 71 (field_access -> primary DOT ID .)
    GT              reduce using rule 71 (field_access -> primary DOT ID .)
    GEQ             reduce using rule 71 (field_access -> primary DOT ID .)
    AND             reduce using rule 71 (field_access -> primary DOT ID .)
    OR              reduce using rule 71 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 71 (field_access -> primary DOT ID .)
    RBRACKET        reduce using rule 71 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 71 (field_access -> primary DOT ID .)


state 148

    (43) stmt -> WHILE LPAREN expr . RPAREN stmt
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RPAREN          shift and go to state 174
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 149

    (62) primary -> NEW ID LPAREN . args_opt RPAREN
    (65) args_opt -> . arg_plus
    (66) args_opt -> .
    (67) arg_plus -> . arg_plus COMMA expr
    (68) arg_plus -> . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    RPAREN          reduce using rule 66 (args_opt -> .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 150
    args_opt                       shift and go to state 175
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    arg_plus                       shift and go to state 152
    assign                         shift and go to state 107

state 150

    (68) arg_plus -> expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    COMMA           reduce using rule 68 (arg_plus -> expr .)
    RPAREN          reduce using rule 68 (arg_plus -> expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 151

    (74) method_invocation -> field_access LPAREN args_opt . RPAREN

    RPAREN          shift and go to state 176


state 152

    (65) args_opt -> arg_plus .
    (67) arg_plus -> arg_plus . COMMA expr

    RPAREN          reduce using rule 65 (args_opt -> arg_plus .)
    COMMA           shift and go to state 177


state 153

    (106) stmt_expr_opt -> stmt_expr .

    SEMICOLON       reduce using rule 106 (stmt_expr_opt -> stmt_expr .)
    RPAREN          reduce using rule 106 (stmt_expr_opt -> stmt_expr .)


state 154

    (44) stmt -> FOR LPAREN stmt_expr_opt . SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt

    SEMICOLON       shift and go to state 178


state 155

    (61) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    EQ              reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    LT              reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    GT              reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 61 (primary -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 61 (primary -> LPAREN expr RPAREN .)


state 156

    (41) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (42) stmt -> IF LPAREN expr . RPAREN stmt
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RPAREN          shift and go to state 179
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 157

    (93) assign -> lhs ASSIGN expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RBRACKET        reduce using rule 93 (assign -> lhs ASSIGN expr .)
    COMMA           reduce using rule 93 (assign -> lhs ASSIGN expr .)
    RPAREN          reduce using rule 93 (assign -> lhs ASSIGN expr .)
    SEMICOLON       reduce using rule 93 (assign -> lhs ASSIGN expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137

  ! PLUS            [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! MULTIPLY        [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! EQ              [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! NEQ             [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! LT              [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! LEQ             [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! GT              [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! GEQ             [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! AND             [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]
  ! OR              [ reduce using rule 93 (assign -> lhs ASSIGN expr .) ]


state 158

    (98) new_array -> NEW type dim_expr_plus . dim_star
    (99) dim_expr_plus -> dim_expr_plus . dim_expr
    (102) dim_star -> . LBRACKET RBRACKET dim_star
    (103) dim_star -> .
    (101) dim_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 182
    PLUS            reduce using rule 103 (dim_star -> .)
    MINUS           reduce using rule 103 (dim_star -> .)
    MULTIPLY        reduce using rule 103 (dim_star -> .)
    DIVIDE          reduce using rule 103 (dim_star -> .)
    EQ              reduce using rule 103 (dim_star -> .)
    NEQ             reduce using rule 103 (dim_star -> .)
    LT              reduce using rule 103 (dim_star -> .)
    LEQ             reduce using rule 103 (dim_star -> .)
    GT              reduce using rule 103 (dim_star -> .)
    GEQ             reduce using rule 103 (dim_star -> .)
    AND             reduce using rule 103 (dim_star -> .)
    OR              reduce using rule 103 (dim_star -> .)
    SEMICOLON       reduce using rule 103 (dim_star -> .)
    RPAREN          reduce using rule 103 (dim_star -> .)
    RBRACKET        reduce using rule 103 (dim_star -> .)
    COMMA           reduce using rule 103 (dim_star -> .)

    dim_expr                       shift and go to state 181
    dim_star                       shift and go to state 180

state 159

    (100) dim_expr_plus -> dim_expr .

    LBRACKET        reduce using rule 100 (dim_expr_plus -> dim_expr .)
    PLUS            reduce using rule 100 (dim_expr_plus -> dim_expr .)
    MINUS           reduce using rule 100 (dim_expr_plus -> dim_expr .)
    MULTIPLY        reduce using rule 100 (dim_expr_plus -> dim_expr .)
    DIVIDE          reduce using rule 100 (dim_expr_plus -> dim_expr .)
    EQ              reduce using rule 100 (dim_expr_plus -> dim_expr .)
    NEQ             reduce using rule 100 (dim_expr_plus -> dim_expr .)
    LT              reduce using rule 100 (dim_expr_plus -> dim_expr .)
    LEQ             reduce using rule 100 (dim_expr_plus -> dim_expr .)
    GT              reduce using rule 100 (dim_expr_plus -> dim_expr .)
    GEQ             reduce using rule 100 (dim_expr_plus -> dim_expr .)
    AND             reduce using rule 100 (dim_expr_plus -> dim_expr .)
    OR              reduce using rule 100 (dim_expr_plus -> dim_expr .)
    SEMICOLON       reduce using rule 100 (dim_expr_plus -> dim_expr .)
    RPAREN          reduce using rule 100 (dim_expr_plus -> dim_expr .)
    RBRACKET        reduce using rule 100 (dim_expr_plus -> dim_expr .)
    COMMA           reduce using rule 100 (dim_expr_plus -> dim_expr .)


state 160

    (101) dim_expr -> LBRACKET . expr RBRACKET
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 183
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 161

    (88) expr -> expr AND expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    AND             reduce using rule 88 (expr -> expr AND expr .)
    OR              reduce using rule 88 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 88 (expr -> expr AND expr .)
    RPAREN          reduce using rule 88 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 88 (expr -> expr AND expr .)
    COMMA           reduce using rule 88 (expr -> expr AND expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134

  ! PLUS            [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! NEQ             [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! LEQ             [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! GEQ             [ reduce using rule 88 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 162

    (87) expr -> expr GEQ expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 87 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 87 (expr -> expr GEQ expr .)
    LT              reduce using rule 87 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 87 (expr -> expr GEQ expr .)
    GT              reduce using rule 87 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 87 (expr -> expr GEQ expr .)
    AND             reduce using rule 87 (expr -> expr GEQ expr .)
    OR              reduce using rule 87 (expr -> expr GEQ expr .)
    SEMICOLON       reduce using rule 87 (expr -> expr GEQ expr .)
    RPAREN          reduce using rule 87 (expr -> expr GEQ expr .)
    RBRACKET        reduce using rule 87 (expr -> expr GEQ expr .)
    COMMA           reduce using rule 87 (expr -> expr GEQ expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! PLUS            [ reduce using rule 87 (expr -> expr GEQ expr .) ]
  ! MINUS           [ reduce using rule 87 (expr -> expr GEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 87 (expr -> expr GEQ expr .) ]
  ! DIVIDE          [ reduce using rule 87 (expr -> expr GEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 163

    (86) expr -> expr GT expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 86 (expr -> expr GT expr .)
    NEQ             reduce using rule 86 (expr -> expr GT expr .)
    LT              reduce using rule 86 (expr -> expr GT expr .)
    LEQ             reduce using rule 86 (expr -> expr GT expr .)
    GT              reduce using rule 86 (expr -> expr GT expr .)
    GEQ             reduce using rule 86 (expr -> expr GT expr .)
    AND             reduce using rule 86 (expr -> expr GT expr .)
    OR              reduce using rule 86 (expr -> expr GT expr .)
    SEMICOLON       reduce using rule 86 (expr -> expr GT expr .)
    RPAREN          reduce using rule 86 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 86 (expr -> expr GT expr .)
    COMMA           reduce using rule 86 (expr -> expr GT expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! PLUS            [ reduce using rule 86 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 86 (expr -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 86 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 86 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 164

    (81) expr -> expr DIVIDE expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 81 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 81 (expr -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 81 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 81 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 81 (expr -> expr DIVIDE expr .)
    NEQ             reduce using rule 81 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 81 (expr -> expr DIVIDE expr .)
    LEQ             reduce using rule 81 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 81 (expr -> expr DIVIDE expr .)
    GEQ             reduce using rule 81 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 81 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 81 (expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 81 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 81 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 81 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 81 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 136 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 165

    (89) expr -> expr OR expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    OR              reduce using rule 89 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 89 (expr -> expr OR expr .)
    RPAREN          reduce using rule 89 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 89 (expr -> expr OR expr .)
    COMMA           reduce using rule 89 (expr -> expr OR expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133

  ! PLUS            [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! NEQ             [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! LEQ             [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! GEQ             [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 89 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 137 ]


state 166

    (85) expr -> expr LEQ expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 85 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 85 (expr -> expr LEQ expr .)
    LT              reduce using rule 85 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 85 (expr -> expr LEQ expr .)
    GT              reduce using rule 85 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 85 (expr -> expr LEQ expr .)
    AND             reduce using rule 85 (expr -> expr LEQ expr .)
    OR              reduce using rule 85 (expr -> expr LEQ expr .)
    SEMICOLON       reduce using rule 85 (expr -> expr LEQ expr .)
    RPAREN          reduce using rule 85 (expr -> expr LEQ expr .)
    RBRACKET        reduce using rule 85 (expr -> expr LEQ expr .)
    COMMA           reduce using rule 85 (expr -> expr LEQ expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! PLUS            [ reduce using rule 85 (expr -> expr LEQ expr .) ]
  ! MINUS           [ reduce using rule 85 (expr -> expr LEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 85 (expr -> expr LEQ expr .) ]
  ! DIVIDE          [ reduce using rule 85 (expr -> expr LEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 167

    (84) expr -> expr LT expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 84 (expr -> expr LT expr .)
    NEQ             reduce using rule 84 (expr -> expr LT expr .)
    LT              reduce using rule 84 (expr -> expr LT expr .)
    LEQ             reduce using rule 84 (expr -> expr LT expr .)
    GT              reduce using rule 84 (expr -> expr LT expr .)
    GEQ             reduce using rule 84 (expr -> expr LT expr .)
    AND             reduce using rule 84 (expr -> expr LT expr .)
    OR              reduce using rule 84 (expr -> expr LT expr .)
    SEMICOLON       reduce using rule 84 (expr -> expr LT expr .)
    RPAREN          reduce using rule 84 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 84 (expr -> expr LT expr .)
    COMMA           reduce using rule 84 (expr -> expr LT expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! PLUS            [ reduce using rule 84 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 84 (expr -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 84 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 84 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 168

    (78) expr -> expr PLUS expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 78 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 78 (expr -> expr PLUS expr .)
    EQ              reduce using rule 78 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 78 (expr -> expr PLUS expr .)
    LT              reduce using rule 78 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 78 (expr -> expr PLUS expr .)
    GT              reduce using rule 78 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 78 (expr -> expr PLUS expr .)
    AND             reduce using rule 78 (expr -> expr PLUS expr .)
    OR              reduce using rule 78 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 78 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 78 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 78 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 78 (expr -> expr PLUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! MULTIPLY        [ reduce using rule 78 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 78 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 169

    (80) expr -> expr MULTIPLY expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 80 (expr -> expr MULTIPLY expr .)
    MINUS           reduce using rule 80 (expr -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 80 (expr -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 80 (expr -> expr MULTIPLY expr .)
    EQ              reduce using rule 80 (expr -> expr MULTIPLY expr .)
    NEQ             reduce using rule 80 (expr -> expr MULTIPLY expr .)
    LT              reduce using rule 80 (expr -> expr MULTIPLY expr .)
    LEQ             reduce using rule 80 (expr -> expr MULTIPLY expr .)
    GT              reduce using rule 80 (expr -> expr MULTIPLY expr .)
    GEQ             reduce using rule 80 (expr -> expr MULTIPLY expr .)
    AND             reduce using rule 80 (expr -> expr MULTIPLY expr .)
    OR              reduce using rule 80 (expr -> expr MULTIPLY expr .)
    SEMICOLON       reduce using rule 80 (expr -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 80 (expr -> expr MULTIPLY expr .)
    RBRACKET        reduce using rule 80 (expr -> expr MULTIPLY expr .)
    COMMA           reduce using rule 80 (expr -> expr MULTIPLY expr .)

  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 136 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 170

    (82) expr -> expr EQ expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 82 (expr -> expr EQ expr .)
    NEQ             reduce using rule 82 (expr -> expr EQ expr .)
    AND             reduce using rule 82 (expr -> expr EQ expr .)
    OR              reduce using rule 82 (expr -> expr EQ expr .)
    SEMICOLON       reduce using rule 82 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 82 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 82 (expr -> expr EQ expr .)
    COMMA           reduce using rule 82 (expr -> expr EQ expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134

  ! PLUS            [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! MULTIPLY        [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! LEQ             [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! GEQ             [ reduce using rule 82 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 171

    (79) expr -> expr MINUS expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    PLUS            reduce using rule 79 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 79 (expr -> expr MINUS expr .)
    EQ              reduce using rule 79 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 79 (expr -> expr MINUS expr .)
    LT              reduce using rule 79 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 79 (expr -> expr MINUS expr .)
    GT              reduce using rule 79 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 79 (expr -> expr MINUS expr .)
    AND             reduce using rule 79 (expr -> expr MINUS expr .)
    OR              reduce using rule 79 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 79 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 79 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 79 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 79 (expr -> expr MINUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136

  ! MULTIPLY        [ reduce using rule 79 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 79 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 143 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! LT              [ shift and go to state 139 ]
  ! LEQ             [ shift and go to state 138 ]
  ! GT              [ shift and go to state 135 ]
  ! GEQ             [ shift and go to state 134 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 172

    (83) expr -> expr NEQ expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    EQ              reduce using rule 83 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 83 (expr -> expr NEQ expr .)
    AND             reduce using rule 83 (expr -> expr NEQ expr .)
    OR              reduce using rule 83 (expr -> expr NEQ expr .)
    SEMICOLON       reduce using rule 83 (expr -> expr NEQ expr .)
    RPAREN          reduce using rule 83 (expr -> expr NEQ expr .)
    RBRACKET        reduce using rule 83 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 83 (expr -> expr NEQ expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134

  ! PLUS            [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! DIVIDE          [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! LT              [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! LEQ             [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! GT              [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! GEQ             [ reduce using rule 83 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 144 ]
  ! AND             [ shift and go to state 133 ]
  ! OR              [ shift and go to state 137 ]


state 173

    (73) array_access -> primary LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    EQ              reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    NEQ             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    LT              reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    LEQ             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    GT              reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    GEQ             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    AND             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    OR              reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    DOT             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    ASSIGN          reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    INC             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)
    DEC             reduce using rule 73 (array_access -> primary LBRACKET expr RBRACKET .)


state 174

    (43) stmt -> WHILE LPAREN expr RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (45) stmt -> . RETURN expr_opt SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . error SEMICOLON
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE
    (23) var_decl -> . type var_list SEMICOLON
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    IF              shift and go to state 85
    WHILE           shift and go to state 66
    FOR             shift and go to state 81
    RETURN          shift and go to state 64
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 90
    error           shift and go to state 185
    LBRACE          shift and go to state 59
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 84
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    array_access                   shift and go to state 70
    stmt_expr                      shift and go to state 75
    stmt                           shift and go to state 184
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    var_decl                       shift and go to state 87
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 175

    (62) primary -> NEW ID LPAREN args_opt . RPAREN

    RPAREN          shift and go to state 186


state 176

    (74) method_invocation -> field_access LPAREN args_opt RPAREN .

    DOT             reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LBRACKET        reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    RBRACKET        reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    PLUS            reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    MINUS           reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    MULTIPLY        reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    DIVIDE          reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    EQ              reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    NEQ             reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LT              reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LEQ             reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    GT              reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    GEQ             reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    AND             reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    OR              reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    SEMICOLON       reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    RPAREN          reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    COMMA           reduce using rule 74 (method_invocation -> field_access LPAREN args_opt RPAREN .)


state 177

    (67) arg_plus -> arg_plus COMMA . expr
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 187
    primary                        shift and go to state 98
    array_access                   shift and go to state 70
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 178

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON . expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (108) expr_opt -> . expr
    (109) expr_opt -> .
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    SEMICOLON       reduce using rule 109 (expr_opt -> .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 106
    array_access                   shift and go to state 70
    primary                        shift and go to state 98
    literal                        shift and go to state 76
    expr_opt                       shift and go to state 188
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 179

    (41) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (42) stmt -> IF LPAREN expr RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (45) stmt -> . RETURN expr_opt SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . error SEMICOLON
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE
    (23) var_decl -> . type var_list SEMICOLON
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    IF              shift and go to state 85
    WHILE           shift and go to state 66
    FOR             shift and go to state 81
    RETURN          shift and go to state 64
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 90
    error           shift and go to state 185
    LBRACE          shift and go to state 59
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 84
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    array_access                   shift and go to state 70
    stmt_expr                      shift and go to state 75
    stmt                           shift and go to state 189
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    var_decl                       shift and go to state 87
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 180

    (98) new_array -> NEW type dim_expr_plus dim_star .

    PLUS            reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    MINUS           reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    MULTIPLY        reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    DIVIDE          reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    EQ              reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    NEQ             reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    LT              reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    LEQ             reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    GT              reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    GEQ             reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    AND             reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    OR              reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    SEMICOLON       reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    RPAREN          reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    RBRACKET        reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)
    COMMA           reduce using rule 98 (new_array -> NEW type dim_expr_plus dim_star .)


state 181

    (99) dim_expr_plus -> dim_expr_plus dim_expr .

    LBRACKET        reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    PLUS            reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    MINUS           reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    MULTIPLY        reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    DIVIDE          reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    EQ              reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    NEQ             reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    LT              reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    LEQ             reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    GT              reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    GEQ             reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    AND             reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    OR              reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    SEMICOLON       reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    RPAREN          reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    RBRACKET        reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)
    COMMA           reduce using rule 99 (dim_expr_plus -> dim_expr_plus dim_expr .)


state 182

    (102) dim_star -> LBRACKET . RBRACKET dim_star
    (101) dim_expr -> LBRACKET . expr RBRACKET
    (75) expr -> . primary
    (76) expr -> . assign
    (77) expr -> . new_array
    (78) expr -> . expr PLUS expr
    (79) expr -> . expr MINUS expr
    (80) expr -> . expr MULTIPLY expr
    (81) expr -> . expr DIVIDE expr
    (82) expr -> . expr EQ expr
    (83) expr -> . expr NEQ expr
    (84) expr -> . expr LT expr
    (85) expr -> . expr LEQ expr
    (86) expr -> . expr GT expr
    (87) expr -> . expr GEQ expr
    (88) expr -> . expr AND expr
    (89) expr -> . expr OR expr
    (90) expr -> . PLUS expr
    (91) expr -> . MINUS expr
    (92) expr -> . NOT expr
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (98) new_array -> . NEW type dim_expr_plus dim_star
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET

    RBRACKET        shift and go to state 190
    PLUS            shift and go to state 102
    MINUS           shift and go to state 100
    NOT             shift and go to state 109
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 99
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86
    ID              shift and go to state 105

    new_array                      shift and go to state 97
    field_access                   shift and go to state 104
    expr                           shift and go to state 183
    primary                        shift and go to state 98
    array_access                   shift and go to state 70
    literal                        shift and go to state 76
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 103
    assign                         shift and go to state 107

state 183

    (101) dim_expr -> LBRACKET expr . RBRACKET
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    RBRACKET        shift and go to state 191
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 184

    (43) stmt -> WHILE LPAREN expr RPAREN stmt .

    RBRACE          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    error           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INC             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 185

    (51) stmt -> error . SEMICOLON

    SEMICOLON       shift and go to state 126


state 186

    (62) primary -> NEW ID LPAREN args_opt RPAREN .

    DOT             reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LBRACKET        reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    PLUS            reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    MINUS           reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    MULTIPLY        reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    DIVIDE          reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    EQ              reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    NEQ             reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LT              reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LEQ             reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    GT              reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    GEQ             reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    AND             reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    OR              reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    COMMA           reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    RPAREN          reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    SEMICOLON       reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)
    RBRACKET        reduce using rule 62 (primary -> NEW ID LPAREN args_opt RPAREN .)


state 187

    (67) arg_plus -> arg_plus COMMA expr .
    (78) expr -> expr . PLUS expr
    (79) expr -> expr . MINUS expr
    (80) expr -> expr . MULTIPLY expr
    (81) expr -> expr . DIVIDE expr
    (82) expr -> expr . EQ expr
    (83) expr -> expr . NEQ expr
    (84) expr -> expr . LT expr
    (85) expr -> expr . LEQ expr
    (86) expr -> expr . GT expr
    (87) expr -> expr . GEQ expr
    (88) expr -> expr . AND expr
    (89) expr -> expr . OR expr

    COMMA           reduce using rule 67 (arg_plus -> arg_plus COMMA expr .)
    RPAREN          reduce using rule 67 (arg_plus -> arg_plus COMMA expr .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 143
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 136
    EQ              shift and go to state 142
    NEQ             shift and go to state 144
    LT              shift and go to state 139
    LEQ             shift and go to state 138
    GT              shift and go to state 135
    GEQ             shift and go to state 134
    AND             shift and go to state 133
    OR              shift and go to state 137


state 188

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt . SEMICOLON stmt_expr_opt RPAREN stmt

    SEMICOLON       shift and go to state 192


state 189

    (41) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt
    (42) stmt -> IF LPAREN expr RPAREN stmt .

    ELSE            shift and go to state 193
    RBRACE          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    error           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    INC             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .)

  ! ELSE            [ reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 190

    (102) dim_star -> LBRACKET RBRACKET . dim_star
    (102) dim_star -> . LBRACKET RBRACKET dim_star
    (103) dim_star -> .

    LBRACKET        shift and go to state 194
    PLUS            reduce using rule 103 (dim_star -> .)
    MINUS           reduce using rule 103 (dim_star -> .)
    MULTIPLY        reduce using rule 103 (dim_star -> .)
    DIVIDE          reduce using rule 103 (dim_star -> .)
    EQ              reduce using rule 103 (dim_star -> .)
    NEQ             reduce using rule 103 (dim_star -> .)
    LT              reduce using rule 103 (dim_star -> .)
    LEQ             reduce using rule 103 (dim_star -> .)
    GT              reduce using rule 103 (dim_star -> .)
    GEQ             reduce using rule 103 (dim_star -> .)
    AND             reduce using rule 103 (dim_star -> .)
    OR              reduce using rule 103 (dim_star -> .)
    SEMICOLON       reduce using rule 103 (dim_star -> .)
    RPAREN          reduce using rule 103 (dim_star -> .)
    RBRACKET        reduce using rule 103 (dim_star -> .)
    COMMA           reduce using rule 103 (dim_star -> .)

    dim_star                       shift and go to state 195

state 191

    (101) dim_expr -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    NEQ             reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    LEQ             reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    GEQ             reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 101 (dim_expr -> LBRACKET expr RBRACKET .)


state 192

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON . stmt_expr_opt RPAREN stmt
    (106) stmt_expr_opt -> . stmt_expr
    (107) stmt_expr_opt -> .
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    RPAREN          reduce using rule 107 (stmt_expr_opt -> .)
    INC             shift and go to state 96
    DEC             shift and go to state 69
    ID              shift and go to state 105
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    primary                        shift and go to state 65
    stmt_expr_opt                  shift and go to state 196
    stmt_expr                      shift and go to state 153
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    method_invocation              shift and go to state 77
    array_access                   shift and go to state 70
    assign                         shift and go to state 94

state 193

    (41) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (45) stmt -> . RETURN expr_opt SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . error SEMICOLON
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE
    (23) var_decl -> . type var_list SEMICOLON
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    IF              shift and go to state 85
    WHILE           shift and go to state 66
    FOR             shift and go to state 81
    RETURN          shift and go to state 64
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 90
    error           shift and go to state 185
    LBRACE          shift and go to state 59
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 84
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    array_access                   shift and go to state 70
    stmt_expr                      shift and go to state 75
    stmt                           shift and go to state 197
    primary                        shift and go to state 65
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    var_decl                       shift and go to state 87
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 194

    (102) dim_star -> LBRACKET . RBRACKET dim_star

    RBRACKET        shift and go to state 190


state 195

    (102) dim_star -> LBRACKET RBRACKET dim_star .

    PLUS            reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    MINUS           reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    MULTIPLY        reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    DIVIDE          reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    EQ              reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    NEQ             reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    LT              reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    LEQ             reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    GT              reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    GEQ             reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    AND             reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    OR              reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    SEMICOLON       reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    RPAREN          reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    RBRACKET        reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)
    COMMA           reduce using rule 102 (dim_star -> LBRACKET RBRACKET dim_star .)


state 196

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt . RPAREN stmt

    RPAREN          shift and go to state 198


state 197

    (41) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    RBRACE          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    error           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INC             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DEC             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT_CONST       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 198

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (45) stmt -> . RETURN expr_opt SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . error SEMICOLON
    (104) stmt_expr -> . assign
    (105) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmt_list RBRACE
    (38) block -> . LBRACE stmt_list error RBRACE
    (23) var_decl -> . type var_list SEMICOLON
    (93) assign -> . lhs ASSIGN expr
    (94) assign -> . lhs INC
    (95) assign -> . INC lhs
    (96) assign -> . lhs DEC
    (97) assign -> . DEC lhs
    (74) method_invocation -> . field_access LPAREN args_opt RPAREN
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (26) type -> . FLOAT
    (27) type -> . ID
    (69) lhs -> . field_access
    (70) lhs -> . array_access
    (71) field_access -> . primary DOT ID
    (72) field_access -> . ID
    (73) array_access -> . primary LBRACKET expr RBRACKET
    (58) primary -> . literal
    (59) primary -> . THIS
    (60) primary -> . SUPER
    (61) primary -> . LPAREN expr RPAREN
    (62) primary -> . NEW ID LPAREN args_opt RPAREN
    (63) primary -> . lhs
    (64) primary -> . method_invocation
    (52) literal -> . INT_CONST
    (53) literal -> . FLOAT_CONST
    (54) literal -> . STRING_CONST
    (55) literal -> . NULL
    (56) literal -> . TRUE
    (57) literal -> . FALSE

    IF              shift and go to state 85
    WHILE           shift and go to state 66
    FOR             shift and go to state 81
    RETURN          shift and go to state 64
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 90
    error           shift and go to state 185
    LBRACE          shift and go to state 59
    INC             shift and go to state 96
    DEC             shift and go to state 69
    INT             shift and go to state 25
    BOOLEAN         shift and go to state 28
    FLOAT           shift and go to state 27
    ID              shift and go to state 84
    THIS            shift and go to state 89
    SUPER           shift and go to state 93
    LPAREN          shift and go to state 83
    NEW             shift and go to state 68
    INT_CONST       shift and go to state 72
    FLOAT_CONST     shift and go to state 67
    STRING_CONST    shift and go to state 71
    NULL            shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 86

    field_access                   shift and go to state 79
    primary                        shift and go to state 65
    array_access                   shift and go to state 70
    stmt                           shift and go to state 199
    stmt_expr                      shift and go to state 75
    literal                        shift and go to state 76
    lhs                            shift and go to state 91
    var_decl                       shift and go to state 87
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 199

    (44) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .

    RBRACE          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    error           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    IF              reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    WHILE           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FOR             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    RETURN          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    BREAK           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    CONTINUE        reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    LBRACE          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INC             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    DEC             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INT             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FLOAT           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    ID              reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    THIS            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    SUPER           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    LPAREN          reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    NEW             reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INT_CONST       reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FLOAT_CONST     reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    STRING_CONST    reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    NULL            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    TRUE            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FALSE           reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    ELSE            reduce using rule 44 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)

